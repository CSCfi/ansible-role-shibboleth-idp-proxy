<?xml version="1.0" encoding="UTF-8"?>
<!-- 
    This file is an EXAMPLE configuration file. While the configuration
    presented in this example file is semi-functional, it isn't very
    interesting. It is here only as a starting point for your deployment
    process.
    
    Very few attribute definitions and data connectors are demonstrated,
    and the data is derived statically from the logged-in username and a
    static example connector.

    Attribute-resolver-full.xml contains more examples of attributes,
    encoders, and data connectors. Deployers should refer to the Shibboleth
    documentation for a complete list of components and their options.
-->
<AttributeResolver xmlns="urn:mace:shibboleth:2.0:resolver" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 	xmlns:enc="urn:mace:shibboleth:2.0:attribute:encoder"
               		xmlns:oidcext="org.geant.idpextension.oidc.attribute.encoder"
               		xsi:schemaLocation="urn:mace:shibboleth:2.0:resolver http://shibboleth.net/schema/idp/shibboleth-attribute-resolver.xsd
               		org.geant.idpextension.oidc.attribute.encoder classpath:/schema/idp-oidc-extension-attribute-encoder.xsd">
               	
    <!-- ========================================== -->
    <!--      Attribute Definitions                 -->
    <!-- ========================================== -->

{%for attribute in shibbolethproxy_attributes['PrincipalName']%}
    <AttributeDefinition id="{{ attribute.id }}" xsi:type="PrincipalName">
      <AttributeEncoder xsi:type="SAML2String" name="{{ shibbolethidp_attributes[attribute.id]['name'] }}" friendlyName="{{ shibbolethidp_attributes[attribute.id].friendlyname }}" encodeType="false" />
{%if 'oidc' in shibbolethidp_configurables%}
      <AttributeEncoder xsi:type="oidcext:OIDCString" name="{{ shibbolethidp_attributes[attribute.id]['oidcname'] }}" setToToken="true" />
{%endif%}
    </AttributeDefinition>
{%endfor%}

{% for attribute in shibbolethproxy_attributes['ScriptedAttribute'] %}
    <AttributeDefinition id="{{ attribute.id }}" xsi:type="ScriptedAttribute">
      <AttributeEncoder xsi:type="SAML2String" name="{{ attribute.name if attribute.name is defined else shibbolethidp_attributes[attribute.id]['name'] }}" friendlyName="{{ attribute.friendlyname if attribute.friendlyname is defined else shibbolethidp_attributes[attribute.id]['friendlyname'] }}" encodeType="false" />
{% if 'oidc' in shibbolethidp_configurables %}
      <AttributeEncoder xsi:type="oidcext:OIDCString" name="{{ attribute.oidcname if attribute.oidcname is defined else shibbolethidp_attributes[attribute.id]['oidcname'] }}" setToToken="true" />
      <Script><![CDATA[
        authnContext = resolutionContext.getParent().getSubcontext("net.shibboleth.idp.authn.context.AuthenticationContext");
        if (authnContext !== null) {
          subject = authnContext.getAuthenticationResult().getSubject();
          principals = subject.getPrincipals(Java.type("fi.mpass.shibboleth.authn.principal.impl.ShibHeaderPrincipal").class);
          iterator = principals.iterator();
          while (iterator.hasNext()) {
            principal = iterator.next();
            if ("{{Â attribute.friendlyname if attribute.friendlyname is defined else shibbolethidp_attributes[attribute.id]['friendlyname'] }}".equals(principal.getKey())) {
              {{ attribute.id }}.addValue(principal.getValue());
            }
          }
        }
      ]]></Script>
{% endif %}
    </AttributeDefinition>

{% endfor %}
{% if shibbolethproxy_attributes['myLDAP'] is defined %}
{%for attribute in shibbolethproxy_attributes['myLDAP']%}
    <AttributeDefinition id="{{ attribute.id }}" xsi:type="{{ attribute.type }}">
      <InputDataConnector ref="myLDAP" attributeNames="{{ attribute.sourceid if attribute.sourceid is defined else attribute.id}}" />
      <AttributeEncoder xsi:type="SAML2String" name="{{ attribute.name }}" friendlyName="{{ attribute.friendlyname if attribute.friendlyname is defined else shibbolethidp_attributes[attribute.id]['friendlyname'] }}" encodeType="false"/>
      <AttributeEncoder xsi:type="oidcext:OIDCString" name="{{ attribute.oidcname if attribute.oidcname is defined else shibbolethidp_attributes[attribute.id]['oidcname'] }}" placeToIDToken="true" setToToken="true" {{ attribute.extra if attribute.extra is defined else '' }} />
    </AttributeDefinition>

{% endfor %}
{% endif %}
    
    {% if 'oidc' in shibbolethidp_configurables %}
    <!-- Subject Identifier is a attribute that must always be resolved.
    There has to be exactly one resolved and filtered attribute that would be encoded as 'sub'.
    This example attribute (the data connector actually ) will generate public or pairwise 'sub' depending on client registration data.  -->

    <AttributeDefinition id="subject" xsi:type="Simple" activationConditionRef="SubjectRequired">
       <InputDataConnector ref="computedSubjectId" attributeNames="subjectId"/>
       <AttributeEncoder xsi:type="oidcext:OIDCString" name="sub" />
    </AttributeDefinition>
    {% endif %}

    <!--
    This is an example of an attribute sourced from a data connector.
    -->
    <AttributeDefinition id="eduPersonScopedAffiliation" xsi:type="Scoped" scope="%{idp.scope}">
     	<InputDataConnector ref="staticAttributes" attributeNames="affiliation" />
	    <AttributeEncoder xsi:type="SAML2ScopedString" name="urn:oid:1.3.6.1.4.1.5923.1.1.1.9" friendlyName="eduPersonScopedAffiliation" encodeType="false" />
       	<AttributeEncoder xsi:type="oidcext:OIDCString" name="eduPersonScopedAffiliation" />
    </AttributeDefinition>

    <!-- ========================================== -->
    <!--      Data Connectors                       -->
    <!-- ========================================== -->

    <DataConnector id="staticAttributes" xsi:type="Static">
      <Attribute id="affiliation">
        <Value>member</Value>
      </Attribute>
    </DataConnector>
{% if shibbolethproxy_attributes['myLDAP'] is defined %}    
    <DataConnector id="myLDAP" xsi:type="LDAPDirectory"
      ldapURL="%{idp.attribute.resolver.LDAP.ldapURL}"
      baseDN="%{idp.attribute.resolver.LDAP.baseDN}"
      principal="%{idp.attribute.resolver.LDAP.bindDN}"
      principalCredential="%{idp.attribute.resolver.LDAP.bindDNCredential}">
      <FilterTemplate>
        <![CDATA[
{% if 'virtu' in shibbolethidp_configurables or 'virtu-test' in shibbolethidp_configurables %}
        (|(eduPersonPrincipalName=$resolutionContext.principal)(virtuPersonPrincipalName=$resolutionContext.principal))
{% else  %}
        (eduPersonPrincipalName=$resolutionContext.principal)
{% endif %}
        ]]>
      </FilterTemplate>
    </DataConnector>
{% endif %}
{% if 'oidc' in shibbolethidp_configurables %}
    <DataConnector id="computedSubjectId" xsi:type="ComputedId" generatedAttributeID="subjectId"
      salt="%{idp.oidc.subject.salt}"
      algorithm="%{idp.oidc.subject.algorithm:SHA}"
      encoding="%{idp.oidc.subject.encoding:BASE32}">
      <InputAttributeDefinition ref="%{idp.oidc.subject.sourceAttribute}"/>
    </DataConnector>    
{% endif %}
</AttributeResolver>
